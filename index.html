<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rainboids: Supercharged Asteroids</title>
    <!-- RIFFWAVE.js v0.03 - Audio encoder -->
    <script src="https://sfxr.me/riffwave.js"></script>
    <script src="https://sfxr.me/sfxr.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            background-color: #000;
        }
        .ui-element {
            position: absolute;
            color: #fff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
            z-index: 10;
        }
        #score {
            top: 20px;
            left: 20px;
            font-size: 24px;
        }
        #wave-display {
            top: 20px;
            right: 20px;
            font-size: 24px;
        }
        #game-message-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 50;
            pointer-events: none; /* Let clicks pass through */
        }
        .message-title {
            font-size: 48px;
            text-shadow: 0 0 15px #f0f;
            animation: pulse 1.5s ease-in-out infinite;
        }
        .message-subtitle {
            font-size: 20px;
            margin-top: 20px;
        }
        #pause-overlay {
            background-color: rgba(0, 0, 0, 0.7);
            display: none; /* Initially hidden */
            pointer-events: all; /* Capture clicks when visible */
        }
        #pause-controls {
            font-size: 16px;
            line-height: 2.5;
            text-align: left;
            border: 2px solid white;
            padding: 20px 40px;
            background-color: rgba(0,0,0,0.5);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
        #pause-controls h2 {
            margin-top: 0;
            font-size: 28px;
            text-align: center;
        }
        #scanline-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: linear-gradient( to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50% );
            background-size: 100% 4px;
            animation: scanline 10s linear infinite;
            z-index: 100;
        }
        @keyframes scanline {
            from { background-position: 0 0; }
            to { background-position: 0 -40px; }
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="scanline-overlay"></div>
    <div id="score" class="ui-element">SCORE: 0</div>
    <div id="wave-display" class="ui-element">WAVE: 1</div>
    
    <!-- This overlay is used for all major game messages like GAME OVER, WAVE CLEARED etc -->
    <div id="game-message-overlay" class="ui-element">
        <h1 id="message-title" class="message-title" style="display: none;"></h1>
        <p id="message-subtitle" class="message-subtitle" style="display: none;"></p>
    </div>

    <!-- This overlay is specifically for the pause menu -->
    <div id="pause-overlay" class="ui-element" style="display: none; justify-content: center; align-items: center; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7);">
        <div id="pause-controls">
            <h2>PAUSED</h2>
            <div>Left/Right Arrows: Rotate</div>
            <div>Up Arrow: Accelerate</div>
            <div>Down Arrow: Decelerate</div>
            <div>Spacebar: Fire</div>
            <div>ESC: Resume</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreEl = document.getElementById('score');
            const waveEl = document.getElementById('wave-display');
            const pauseOverlay = document.getElementById('pause-overlay');
            const messageTitle = document.getElementById('message-title');
            const messageSubtitle = document.getElementById('message-subtitle');

            let width = window.innerWidth, height = window.innerHeight;
            canvas.width = width; canvas.height = height;
            window.addEventListener('resize', () => {
                width = window.innerWidth; height = window.innerHeight;
                canvas.width = width; canvas.height = height;
            });

            // --- Game Constants ---
            const SHIP_SIZE = 30, SHIP_THRUST = 0.15, SHIP_FRICTION = 0.985;
            const MAX_V = 6, TURN_SPEED = 0.06, BULLET_SPEED = 8;
            const INITIAL_AST_COUNT = 3, AST_SPEED = 1.2;
            const STAR_COUNT = 150, MIN_STAR_DIST = 30, STAR_ATTR = 0.05, STAR_FRIC = 0.98;
            const HIT_SCORE = 10, DESTROY_SCORE = 500, STAR_SCORE = 4;
            const BURST_STAR_SCORE = 7;
            const BURST_STAR_ATTRACT_DIST = 350;
            const BURST_STAR_ATTR = 0.15;
            const MIN_AST_RAD = 15, SAFE_ZONE = 250;
            const NORMAL_STAR_COLORS = ['#a6b3ff', '#c3a6ff', '#f3a6ff', '#ffa6f8', '#ffa6c7', '#ff528e', '#d98cff'];

            // --- Game State ---
            let score = 0, currentWave = 0, gameState = 'START';
            let audioReady = false;
            
            // --- Input Handling ---
            const keys = { up: false, down: false, left: false, right: false, space: false };
            document.addEventListener('keydown', e => {
                if (!audioReady) { audioReady = true; }
                
                if (e.code === 'Enter' && gameState === 'GAME_OVER') {
                    init();
                    return;
                }

                if (e.code === 'Escape') {
                    if (gameState === 'PLAYING' || gameState === 'WAVE_TRANSITION') {
                        gameState = 'PAUSED';
                        pauseOverlay.style.display = 'flex';
                    } else if (gameState === 'PAUSED') {
                        gameState = 'PLAYING';
                        pauseOverlay.style.display = 'none';
                    }
                    return;
                }
                
                if (gameState === 'GAME_OVER' || gameState === 'PAUSED') return;
                
                switch (e.code) {
                    case 'ArrowUp': keys.up = true; break;
                    case 'ArrowDown': keys.down = true; break;
                    case 'ArrowLeft': keys.left = true; break;
                    case 'ArrowRight': keys.right = true; break;
                    case 'Space': keys.space = true; break;
                }
            });

            document.addEventListener('keyup', e => {
                switch (e.code) {
                    case 'ArrowUp': keys.up = false; break;
                    case 'ArrowDown': keys.down = false; break;
                    case 'ArrowLeft': keys.left = false; break;
                    case 'ArrowRight': keys.right = false; break;
                    case 'Space': keys.space = false; break;
                }
            });

            // --- Utility Functions ---
            const random = (a, b) => Math.random() * (b - a) + a;
            function wrap(o) {
                if (o.x < 0) o.x += width; if (o.x > width) o.x -= width;
                if (o.y < 0) o.y += height; if (o.y > height) o.y -= height;
            }
            function collision(a, b) {
                const dx = a.x - b.x, dy = a.y - b.y;
                return Math.hypot(dx, dy) < a.radius + b.radius;
            }

            // --- Object Pooling ---
            class PoolManager {
                constructor(ObjectClass, initialSize) {
                    this.ObjectClass = ObjectClass;
                    this.pool = [];
                    this.activeObjects = [];
                    for (let i = 0; i < initialSize; i++) {
                        this.pool.push(new ObjectClass());
                    }
                }

                get(...args) {
                    let obj;
                    if (this.pool.length > 0) {
                        obj = this.pool.pop();
                    } else {
                        obj = new this.ObjectClass();
                    }
                    obj.reset(...args);
                    this.activeObjects.push(obj);
                    return obj;
                }

                release(obj) {
                    const index = this.activeObjects.indexOf(obj);
                    if (index > -1) {
                        this.activeObjects.splice(index, 1);
                        obj.active = false;
                        this.pool.push(obj);
                    }
                }
                
                updateActive(...args) {
                    for (let i = this.activeObjects.length - 1; i >= 0; i--) {
                        this.activeObjects[i].update(...args);
                    }
                }

                drawActive() {
                    this.activeObjects.forEach(obj => obj.draw());
                }
            }

            // --- Entity Classes ---
            class Player {
                constructor() { this.reset(); }
                reset() {
                    this.x = width / 2; this.y = height / 2;
                    this.radius = SHIP_SIZE / 2;
                    this.angle = -Math.PI / 2;
                    this.vel = { x: 0, y: 0 };
                    this.canShoot = true;
                    this.active = true;
                }
                update() {
                    if (!this.active) return;
                    if (keys.left) this.angle -= TURN_SPEED;
                    if (keys.right) this.angle += TURN_SPEED;
                    if (keys.up) {
                        this.vel.x += Math.cos(this.angle) * SHIP_THRUST;
                        this.vel.y += Math.sin(this.angle) * SHIP_THRUST;
                        const rear = this.angle + Math.PI, dist = this.radius * 1.2, spread = this.radius * 0.6;
                        const bx = this.x + Math.cos(rear) * dist, by = this.y + Math.sin(rear) * dist;
                        const p1x = bx + Math.cos(rear + Math.PI / 2) * spread / 2, p1y = by + Math.sin(rear + Math.PI / 2) * spread / 2;
                        const p2x = bx + Math.cos(rear - Math.PI / 2) * spread / 2, p2y = by + Math.sin(rear - Math.PI / 2) * spread / 2;
                        particlePool.get(p1x, p1y, 'thrust', rear);
                        particlePool.get(p2x, p2y, 'thrust', rear);
                    } else if (keys.down) { this.vel.x *= SHIP_FRICTION * 0.95; this.vel.y *= SHIP_FRICTION * 0.95; }
                    else { this.vel.x *= SHIP_FRICTION; this.vel.y *= SHIP_FRICTION; }
                    
                    const mag = Math.hypot(this.vel.x, this.vel.y);
                    if (mag > MAX_V) { this.vel.x = (this.vel.x / mag) * MAX_V; this.vel.y = (this.vel.y / mag) * MAX_V; }
                    
                    this.x += this.vel.x; this.y += this.vel.y; wrap(this);

                    if (keys.space && this.canShoot) {
                        playSound(sounds.shoot);
                        bulletPool.get(this.x, this.y, this.angle);
                        this.canShoot = false;
                        setTimeout(() => this.canShoot = true, 200);
                    }
                }
                draw() {
                    if (!this.active) return;
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle + Math.PI / 2);
                    ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2;
                    ctx.shadowColor = '#0ff'; ctx.shadowBlur = 15;
                    ctx.globalCompositeOperation = 'lighter';
                    const r = this.radius, w = 1.15;
                    ctx.beginPath(); ctx.moveTo(0, -r); ctx.lineTo(r * 0.96 * w, r * 0.9); ctx.lineTo(r * 0.6 * w, r * 0.9); ctx.lineTo(0, -r * 0.1); ctx.closePath(); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -r); ctx.lineTo(-r * 0.96 * w, r * 0.9); ctx.lineTo(-r * 0.6 * w, r * 0.9); ctx.lineTo(0, -r * 0.1); ctx.closePath(); ctx.stroke();
                    ctx.restore();
                }
                die() {
                    this.active = false;
                    playSound(sounds.playerExplosion);
                    particlePool.get(this.x, this.y, 'playerExplosion');
                }
            }

            class Bullet {
                constructor() { this.active = false; }
                reset(x, y, a) {
                    this.x = x + Math.cos(a) * (SHIP_SIZE / 1.5); this.y = y + Math.sin(a) * (SHIP_SIZE / 1.5);
                    this.radius = 3; this.angle = a;
                    this.vel = { x: Math.cos(a) * BULLET_SPEED, y: Math.sin(a) * BULLET_SPEED };
                    this.life = 0; this.waveAmp = 4; this.active = true;
                    this.mass = 1; 
                }
                update() {
                    if (!this.active) return;
                    this.life++;
                    const perp = this.angle + Math.PI / 2;
                    const off = Math.sin(this.life * 0.2) * this.waveAmp;
                    this.x += this.vel.x + Math.cos(perp) * off;
                    this.y += this.vel.y + Math.sin(perp) * off;
                    if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                        bulletPool.release(this);
                    }
                }
                draw() {
                    if (!this.active) return;
                    ctx.fillStyle = `hsl(${this.life * 5 % 360}, 100%, 50%)`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI); ctx.fill();
                }
            }
            
            class Asteroid {
                constructor() { this.active = false; }
                reset(x, y, baseR) {
                    this.x=x; this.y=y;
                    this.vel={x:random(-AST_SPEED,AST_SPEED)||0.2, y:random(-AST_SPEED,AST_SPEED)||0.2};
                    this.rot3D={x:0,y:0,z:0};
                    this.rotVel3D={x:random(-0.02,0.02),y:random(-0.02,0.02),z:random(-0.02,0.02)};
                    this.fov=300; this.active = true;
                    this.edges=[[0,1],[0,5],[0,7],[0,10],[0,11],[1,5],[1,7],[1,8],[1,9],[2,3],[2,4],[2,6],[2,10],[2,11],[3,4],[3,6],[3,8],[3,9],[4,5],[4,9],[4,11],[5,9],[5,11],[6,7],[6,8],[6,10],[7,8],[7,10],[8,9],[10,11]];

                    this.rescale(baseR || random(40,60));
                }
                rescale(newBaseRadius) {
                    this.baseRadius = newBaseRadius;
                    var t=(1+Math.sqrt(5))/2, pts=[[-1,t,0],[1,t,0],[-1,-t,0],[1,-t,0],[0,-1,t],[0,1,t],[0,-1,-t],[0,1,-t],[t,0,-1],[t,0,1],[-t,0,-1],[-t,0,1]];
                    this.vertices3D=pts.map(v=>{
                        var d=1+random(-0.25,0.25);
                        return{x:v[0]*this.baseRadius*d, y:v[1]*this.baseRadius*d, z:v[2]*this.baseRadius*d};
                    });
                    
                    var minR=Infinity,maxR=0;
                    this.vertices3D.forEach(v=>{var d=Math.hypot(v.x,v.y,v.z);if(d<minR)minR=d;if(d>maxR)maxR=d;});
                    this.radius=(minR+maxR)/2;
                    this.mass = (4 / 3) * Math.PI * Math.pow(this.radius, 3);
                    this.project();
                }
                project() {
                    let cosX=Math.cos(this.rot3D.x),sinX=Math.sin(this.rot3D.x), cosY=Math.cos(this.rot3D.y),sinY=Math.sin(this.rot3D.y), cosZ=Math.cos(this.rot3D.z),sinZ=Math.sin(this.rot3D.z);
                    this.projectedVertices=this.vertices3D.map(v=>{
                        let x=v.x,y=v.y,z=v.z;
                        let tx=x,ty=y; x=tx*cosZ-ty*sinZ; y=tx*sinZ+ty*cosZ;
                        tx=y;let tz=z; y=tx*cosX-tz*sinX; z=tx*sinX+tz*cosX;
                        tx=x;tz=z; x=tx*cosY+tz*sinY; z=-tx*sinY+tz*cosY;
                        return {x:(x*this.fov)/(this.fov+z),y:(y*this.fov)/(this.fov+z),depth:z};
                    });
                }
                update() {
                    if (!this.active) return;
                    this.x += this.vel.x;
                    this.y += this.vel.y;

                    const wrapBuffer = this.baseRadius * 4;
                    if (this.x < -wrapBuffer) this.x = width + wrapBuffer;
                    if (this.x > width + wrapBuffer) this.x = -wrapBuffer;
                    if (this.y < -wrapBuffer) this.y = height + wrapBuffer;
                    if (this.y > height + wrapBuffer) this.y = -wrapBuffer;
                    
                    this.rot3D.x+=this.rotVel3D.x;this.rot3D.y+=this.rotVel3D.y;this.rot3D.z+=this.rotVel3D.z;
                    this.project();
                }
                draw() {
                    if (!this.active) return;
                    ctx.save();ctx.translate(this.x,this.y);
                    ctx.strokeStyle='white';ctx.lineWidth=1.5;
                    this.edges.forEach(e=>{
                        let v1=this.projectedVertices[e[0]],v2=this.projectedVertices[e[1]];
                        if(!v1||!v2)return;
                        let avg=(v1.depth+v2.depth)/2;
                        ctx.globalAlpha = Math.max(0.1, Math.pow(Math.max(0, (this.fov - avg) / (this.fov + this.radius)), 2.5));
                        ctx.beginPath();ctx.moveTo(v1.x,v1.y);ctx.lineTo(v2.x,v2.y);ctx.stroke();
                    });
                    ctx.restore();
                }
            }

            class Particle {
                constructor() { this.active = false; }
                reset(x, y, type, ...args) {
                    this.x = x; this.y = y; this.active = true;
                    this.type = type;
                    switch(type) {
                        case 'explosion': {
                            this.radius = random(1, 3);
                            this.vel = { x: random(-3, 3), y: random(-3, 3) };
                            this.life = 1;
                            this.color = `hsl(${random(0,360)},100%,70%)`;
                            break;
                        }
                        case 'playerExplosion': {
                            this.life = 1; this.radius = 0;
                            this.maxRadius = 150;
                            this.color = '#0ff';
                            break;
                        }
                        case 'thrust': {
                            const [angle] = args;
                            const cols = ['#ff4500', '#ff8c00', '#ffa500'];
                            this.color = cols[Math.floor(random(0, cols.length))];
                            const a = angle + random(-0.26, 0.26), s = random(1.5, 3);
                            this.radius = random(1, 2.5);
                            this.vel = { x: Math.cos(a) * s, y: Math.sin(a) * s };
                            this.life = 1;
                            break;
                        }
                        case 'pickupPulse': {
                            this.life = 1; this.radius = 0; this.maxRadius = 30; this.color = 'white';
                            break;
                        }
                    }
                }
                update() {
                    if (!this.active) return;
                    switch(this.type) {
                        case 'explosion':
                        case 'thrust':
                            this.x += this.vel.x; this.y += this.vel.y; this.life -= 0.02;
                            break;
                        case 'playerExplosion':
                            this.life -= 0.02; this.radius = (1-this.life**2) * this.maxRadius;
                             break;
                        case 'pickupPulse':
                            this.life -= 0.04; this.radius = (1-this.life) * this.maxRadius;
                            break;
                    }
                    if (this.life <= 0) particlePool.release(this);
                }
                draw() {
                    if (!this.active) return;
                    ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
                    switch(this.type) {
                        case 'explosion':
                        case 'thrust':
                            ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI); ctx.fill();
                            break;
                        case 'playerExplosion':
                        case 'pickupPulse':
                            ctx.strokeStyle = this.color; ctx.lineWidth = 3;
                            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI); ctx.stroke();
                            break;
                    }
                    ctx.restore();
                }
            }

            class LineDebris {
                constructor() { this.active = false; }
                reset(x, y, p1, p2) {
                    this.x=x;this.y=y;this.life=1;this.p1=p1;this.p2=p2;this.active = true;
                    const midX=(p1.x+p2.x)/2,midY=(p1.y+p2.y)/2;
                    const ang=Math.atan2(midY,midX),spd=random(1,3);
                    this.vel={x:Math.cos(ang)*spd,y:Math.sin(ang)*spd};
                    this.rot=0;this.rotVel=random(-0.1,0.1);
                }
                update() {
                    if (!this.active) return;
                    this.x+=this.vel.x;this.y+=this.vel.y; this.rot+=this.rotVel; this.life-=0.02;
                    if (this.life <= 0) lineDebrisPool.release(this);
                }
                draw() {
                    if (!this.active) return;
                    ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.rot);
                    ctx.globalAlpha=Math.max(0,this.life);ctx.strokeStyle='white';ctx.lineWidth=1.5;
                    ctx.beginPath();ctx.moveTo(this.p1.x,this.p1.y);ctx.lineTo(this.p2.x,this.p2.y);ctx.stroke();
                    ctx.restore();
                }
            }

            class Star {
                constructor(x, y, burst = false) { this.x=x||random(0,width);this.y=y||random(0,height); const sizeRoll=Math.pow(Math.random(),6); this.z=(1-sizeRoll)*4+0.5;this.radius=this.z;this.opacity=0; this.opacityOffset=Math.random()*Math.PI*2; this.twinkleSpeed=random(0.01,0.05); const shapes=['point','point','point','point','point','point','point','diamond','star4','star8','plus']; this.shape=shapes[Math.floor(Math.random()*shapes.length)]; this.points=Math.floor(random(4,7))*2;this.innerRadiusRatio=random(0.4,0.8); this.isBurst=burst;this.vel={x:0,y:0}; if(burst){const ang=random(0,2*Math.PI),spd=random(2,5);this.vel={x:Math.cos(ang)*spd,y:Math.sin(ang)*spd}; this.color = '#00ff7f';} else { this.color = NORMAL_STAR_COLORS[Math.floor(Math.random() * NORMAL_STAR_COLORS.length)];} }
                update(shipVel, playerPos) {
                    if (this.isBurst) {
                        this.vel.x *= STAR_FRIC;
                        this.vel.y *= STAR_FRIC;
                        this.x += this.vel.x;
                        this.y += this.vel.y;
                        this.opacity = 1;
                        
                        const dx = playerPos.x - this.x, dy = playerPos.y - this.y, dist = Math.hypot(dx, dy);
                        if (player.active && dist < BURST_STAR_ATTRACT_DIST) {
                            this.x += (dx / dist) * BURST_STAR_ATTR * this.z;
                            this.y += (dy / dist) * BURST_STAR_ATTR * this.z;
                        }
                    } else {
                        const dx = playerPos.x - this.x, dy = playerPos.y - this.y, dist = Math.hypot(dx, dy);
                        if (player.active && dist < 150) {
                            this.x += (dx / dist) * STAR_ATTR * this.z;
                            this.y += (dy / dist) * STAR_ATTR * this.z;
                        }
                        this.opacityOffset += this.twinkleSpeed;
                        this.opacity = (Math.sin(this.opacityOffset) + 1) / 2 * 0.9 + 0.1;
                    }
                    
                    this.x -= shipVel.x / (6 - this.z);
                    this.y -= shipVel.y / (6 - this.z);
                    wrap(this);
                }
                draw() {
                    ctx.save();
                    ctx.translate(this.x,this.y);
                    ctx.globalAlpha=this.opacity*(this.z/5);
                    
                    if (this.shape==='point'){
                        if (this.isBurst) {
                            ctx.fillStyle = '#ffd700'; // Yellow outline
                            ctx.fillRect(-this.radius/2 - 1, -this.radius/2 - 1, this.radius + 2, this.radius + 2);
                        }
                        ctx.fillStyle = this.color;
                        ctx.fillRect(-this.radius/2, -this.radius/2, this.radius, this.radius);
                    } else {
                        // Draw Path
                        ctx.beginPath();
                        switch(this.shape){
                            case 'diamond':ctx.moveTo(0,-this.radius);ctx.lineTo(this.radius*0.7,0);ctx.lineTo(0,this.radius);ctx.lineTo(-this.radius*0.7,0);ctx.closePath();break;
                            case 'plus':ctx.moveTo(0,-this.radius);ctx.lineTo(0,this.radius);ctx.moveTo(-this.radius,0);ctx.lineTo(this.radius,0);break;
                            case 'star4':for(let i=0;i<8;i++){const a=i*Math.PI/4,r=i%2===0?this.radius:this.radius*0.4;ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r);}ctx.closePath();break;
                            case 'star8':for(let i=0;i<this.points*2;i++){const a=i*Math.PI/this.points,r=i%2===0?this.radius:this.innerRadiusRatio;ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r);}ctx.closePath();break;
                            default:ctx.moveTo(-this.radius,-this.radius);ctx.lineTo(this.radius,this.radius);ctx.moveTo(this.radius,-this.radius);ctx.lineTo(-this.radius,this.radius);break;
                        }
                        // Draw outline for burst stars
                        if (this.isBurst) {
                            ctx.strokeStyle = '#ffd700';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        // Draw main star
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 0.5+this.z/5;
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            // --- Game Objects and Pools ---
            let player, stars, bulletPool, particlePool, lineDebrisPool, asteroidPool;
            
            // --- Game Logic ---
            function init() {
                score = 0;
                currentWave = 0;
                
                player = new Player();
                stars = [];
                for(let i = 0; i < STAR_COUNT; i++) spawnStar();

                bulletPool = new PoolManager(Bullet, 20);
                particlePool = new PoolManager(Particle, 100);
                lineDebrisPool = new PoolManager(LineDebris, 100);
                asteroidPool = new PoolManager(Asteroid, 20);

                hideMessage();
                gameState = 'PLAYING';
                startNextWave();
            }

            function startNextWave() {
                currentWave++;
                waveEl.textContent = `WAVE: ${currentWave}`;
                showMessage(`WAVE ${currentWave}`, '', 1500);

                const numAsteroids = INITIAL_AST_COUNT + (currentWave - 1) * 2;
                for (let i = 0; i < numAsteroids; i++) {
                    spawnAsteroidOffscreen();
                }
                
                setTimeout(() => {
                    if (gameState === 'WAVE_TRANSITION') gameState = 'PLAYING';
                }, 1500);
            }

            function spawnAsteroidOffscreen() {
                let x, y, edge = Math.floor(random(0, 4)), r = random(30, 60);
                const spawnBuffer = r * 4;
                switch (edge) {
                    case 0: x = random(0, width); y = -spawnBuffer; break;
                    case 1: x = width + spawnBuffer; y = random(0, height); break;
                    case 2: x = random(0, width); y = height + spawnBuffer; break;
                    default: x = -spawnBuffer; y = random(0, height); break;
                }
                
                const newAst = asteroidPool.get(x, y, r);
                const tx=random(width*0.3,width*0.7), ty=random(height*0.3,height*0.7);
                const ang=Math.atan2(ty-y, tx-x);
                const spd = Math.min(2.5, AST_SPEED + (currentWave - 1) * 0.1);
                newAst.vel = {x:Math.cos(ang)*spd, y:Math.sin(ang)*spd};
            }

            function spawnStar() {
                let s, tooClose, attempts = 0;
                do {
                    tooClose = false; s = new Star();
                    for(let o of stars){ if(Math.hypot(s.x-o.x,s.y-o.y)<MIN_STAR_DIST){tooClose=true;break;} }
                    attempts++; if(attempts > 100) break;
                } while (tooClose);
                stars.push(s);
            }
            
            function createDebris(ast) {
                for (let i = 0; i < 25; i++) {
                    particlePool.get(ast.x, ast.y, 'explosion');
                }
                ast.edges.forEach(e => {
                    const p1 = ast.vertices3D[e[0]], p2 = ast.vertices3D[e[1]];
                    lineDebrisPool.get(ast.x, ast.y, p1, p2);
                });
            }

            function createStarBurst(x, y) {
                const count = 20;
                for (let i = 0; i < count; i++) {
                    stars.push(new Star(x, y, true));
                }
            }

            function handleCollisions() {
                // Player vs Asteroids
                if (player.active) {
                    for (const ast of asteroidPool.activeObjects) {
                        if (collision(player, ast)) {
                            player.die();
                            gameState = 'GAME_OVER';
                            showMessage('GAME OVER', 'Press Enter to Restart');
                            return;
                        }
                    }
                }

                // Bullets vs asteroids
                for (let i = bulletPool.activeObjects.length - 1; i >= 0; i--) {
                    const bullet = bulletPool.activeObjects[i];
                    for (let j = asteroidPool.activeObjects.length - 1; j >= 0; j--) {
                        const ast = asteroidPool.activeObjects[j];
                        if (collision(bullet, ast)) {
                            score += HIT_SCORE;
                            playSound(sounds.hit);
                            particlePool.get(bullet.x, bullet.y, 'explosion');
                            
                            const DESTRUCTION_THRESHOLD = MIN_AST_RAD + 5;
                            if (ast.baseRadius <= DESTRUCTION_THRESHOLD) {
                                score += DESTROY_SCORE;
                                playSound(sounds.explosion);
                                createDebris(ast);
                                createStarBurst(ast.x, ast.y);
                                asteroidPool.release(ast);
                            } else {
                                const count = Math.random() < 0.5 ? 2 : 3;
                                const newR = ast.baseRadius / Math.sqrt(count);
                                
                                const totalMass = ast.mass + bullet.mass;
                                const v_com_x = (ast.vel.x * ast.mass + bullet.vel.x * bullet.mass) / totalMass;
                                const v_com_y = (ast.vel.y * ast.mass + bullet.vel.y * bullet.mass) / totalMass;
                                const explosionSpeed = 1;

                                if (newR < MIN_AST_RAD) {
                                    score += DESTROY_SCORE;
                                    playSound(sounds.explosion);
                                    createDebris(ast);
                                    createStarBurst(ast.x, ast.y);
                                } else {
                                    for (let k = 0; k < count; k++) {
                                        const newAst = asteroidPool.get(ast.x + random(-2, 2), ast.y + random(-2, 2), newR);
                                        const angle = (k / count) * (2 * Math.PI) + random(-0.2, 0.2);
                                        const kick_x = Math.cos(angle) * explosionSpeed;
                                        const kick_y = Math.sin(angle) * explosionSpeed;
                                        newAst.vel.x = v_com_x + kick_x;
                                        newAst.vel.y = v_com_y + kick_y;
                                    }
                                }
                                asteroidPool.release(ast);
                            }
                            bulletPool.release(bullet);
                            break;
                        }
                    }
                }

                // Asteroid-asteroid physics
                const activeAsteroids = asteroidPool.activeObjects;
                for (let i = 0; i < activeAsteroids.length; i++) {
                    for (let j = i + 1; j < activeAsteroids.length; j++) {
                        let a1 = activeAsteroids[i], a2 = activeAsteroids[j];
                        if (collision(a1, a2)) {
                            let dx=a2.x-a1.x,dy=a2.y-a1.y,dist=Math.hypot(dx,dy);
                            if(dist===0)continue;
                            let nx=dx/dist,ny=dy/dist,tx=-ny,ty=nx;
                            let dpTan1=a1.vel.x*tx+a1.vel.y*ty,dpTan2=a2.vel.x*tx+a2.vel.y*ty;
                            let dpNorm1=a1.vel.x*nx+a1.vel.y*ny,dpNorm2=a2.vel.x*nx+a2.vel.y*ny;
                            let m1=(dpNorm1*(a1.mass-a2.mass)+2*a2.mass*dpNorm2)/(a1.mass+a2.mass);
                            let m2=(dpNorm2*(a2.mass-a1.mass)+2*a1.mass*dpNorm1)/(a1.mass+a2.mass);
                            a1.vel={x:tx*dpTan1+nx*m1,y:ty*dpTan1+ny*m1};
                            a2.vel={x:tx*dpTan2+nx*m2,y:ty*dpTan2+ny*m2};
                            let overlap=0.5*(a1.radius+a2.radius-dist+1);
                            a1.x-=overlap*nx; a1.y-=overlap*ny; a2.x+=overlap*nx; a2.y+=overlap*ny;
                        }
                    }
                }

                // Player vs Stars (Pickup)
                for (let i = stars.length - 1; i >= 0; i--) {
                    const star = stars[i];
                    if (player.active && collision(player, star)) {
                        score += star.isBurst ? BURST_STAR_SCORE : STAR_SCORE;
                        playSound(sounds.coin);
                        particlePool.get(star.x, star.y, 'pickupPulse');
                        
                        if (!star.isBurst) {
                            spawnStar();
                        }
                        stars.splice(i, 1);
                    }
                }
            }
            
            function showMessage(title, subtitle = '', duration = 0) {
                messageTitle.textContent = title;
                messageTitle.style.display = 'block';
                messageSubtitle.textContent = subtitle;
                messageSubtitle.style.display = subtitle ? 'block' : 'none';

                if (duration > 0) {
                    setTimeout(hideMessage, duration);
                }
            }

            function hideMessage() {
                messageTitle.style.display = 'none';
                messageSubtitle.style.display = 'none';
            }

            function update() {
                player.update();
                bulletPool.updateActive();
                particlePool.updateActive();
                lineDebrisPool.updateActive();
                asteroidPool.updateActive();
                stars.forEach(s => s.update(player.vel, player));

                handleCollisions();
                
                if (gameState === 'PLAYING' && asteroidPool.activeObjects.length === 0) {
                    gameState = 'WAVE_TRANSITION';
                    setTimeout(startNextWave, 2000); 
                }

                scoreEl.textContent = `SCORE: ${score}`;
            }

            function draw() {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, width, height);

                stars.forEach(s => s.draw());
                lineDebrisPool.drawActive();
                particlePool.drawActive();
                asteroidPool.drawActive();
                bulletPool.drawActive();
                player.draw();
            }

            function gameLoop() {
                if (gameState === 'PLAYING' || gameState === 'WAVE_TRANSITION') {
                    update();
                } else if (gameState === 'GAME_OVER') {
                    particlePool.updateActive();
                    lineDebrisPool.updateActive();
                } else if (gameState === 'PAUSED') {
                    // Do nothing
                }

                draw();
                requestAnimationFrame(gameLoop);
            }

            // --- Sound Definitions ---
            const sounds = {
                shoot: sfxr.generate("laserShoot"),
                hit: sfxr.generate("hitHurt"),
                coin: sfxr.generate("pickupCoin"),
                explosion: sfxr.generate("explosion"),
                playerExplosion: sfxr.generate("explosion")
            };
            sounds.playerExplosion.attackTime = 0.2;
            sounds.playerExplosion.sustainTime = 0.3;
            sounds.playerExplosion.startFrequency = 400;
            sounds.playerExplosion.minFrequency = 100;

            function playSound(params) {
                if (audioReady) {
                    sfxr.toAudio(params).play();
                }
            }

            // --- Start Game ---
            init();
            gameLoop();
        });
    </script>
</body>
</html>
