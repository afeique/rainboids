// Collectible star entity with various shapes and behaviors
import { GAME_CONFIG, NORMAL_STAR_COLORS, STAR_SHAPES } from '../constants.js';
import { random, wrap } from '../utils.js';

function isMobile() {
    return window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse), (max-width: 768px)').matches;
}

export class CollectibleStar {
    constructor() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.active = false;
    }
    
    reset(x, y, burst = false, z, density) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.density = density;
        
        let scale = isMobile() ? GAME_CONFIG.MOBILE_SCALE : 1;
        
        // Radius and twinkle speed are now affected by density
        const densityFactor = 0.7 + (this.density || 0.5) * 0.6;
        
        // 5% chance for a "big star" - much larger and brighter
        const isBigStar = Math.random() < 0.05;
        if (isBigStar) {
            this.radius = (this.z * 1.8 + 0.8) * scale * densityFactor; // Big stars
            this.isBigStar = true;
        } else {
            this.radius = (this.z * 0.6 + 0.2) * scale * densityFactor; // Normal small stars
            this.isBigStar = false;
        }
        
        this.opacity = 0;
        this.opacityOffset = Math.random() * Math.PI * 2;
        this.twinkleSpeed = random(0.01, 0.03) * (1 + this.z * 0.3) * densityFactor;
        
        this.shape = STAR_SHAPES[Math.floor(Math.random() * STAR_SHAPES.length)];
        this.points = Math.floor(random(4, 7)) * 2;
        this.innerRadiusRatio = random(0.4, 0.8);
        
        // Add rotation and size variation
        this.rotation = 0;
        this.rotationSpeed = random(-0.02, 0.02);
        // Big stars get larger size variation
        if (this.isBigStar) {
            this.sizeVariation = random(1.2, 2.0); // Big stars: 120% to 200% size variation
        } else {
            this.sizeVariation = random(0.7, 1.3); // Normal stars: 70% to 130% size variation
        }
        this.pulseSpeed = random(0.005, 0.015);
        this.pulseOffset = Math.random() * Math.PI * 2;
        
        this.isBurst = burst;
        this.vel = { x: 0, y: 0 };
        this.active = true;
        
        if (burst) {
            // Burst stars are not generated by the noise field, so they need default values
            this.x = x || random(0, this.width);
            this.y = y || random(0, this.height);
            this.z = random(1.5, 3.0); // Close and bright
            this.density = 0.8;
            this.radius = (this.z * 1.2 + 0.4) * scale * 1.2; // Extra large

            // Initial velocity will be set by createStarBurst for explosion effect
            this.vel = { x: 0, y: 0 };
            this.color = '#00ff7f';
            this.borderColor = '#ffd700';
            this.life = 1800;
        } else {
            this.color = NORMAL_STAR_COLORS[Math.floor(Math.random() * NORMAL_STAR_COLORS.length)];
            this.borderColor = NORMAL_STAR_COLORS[Math.floor(Math.random() * NORMAL_STAR_COLORS.length)];
            this.life = -1;
        }
    }
    
    update(shipVel, playerPos, tractorEngaged) {
        if (!this.active) return;
        
        if (this.isBurst) {
            this.life--;
            if (this.life <= 0) {
                this.active = false;
                return;
            }
            
            this.vel.x *= GAME_CONFIG.STAR_FRIC;
            this.vel.y *= GAME_CONFIG.STAR_FRIC;
            this.x += this.vel.x;
            this.y += this.vel.y;
            
            this.opacity = Math.min(1, this.life / 120);
            
            // Home directly toward player
            const dx = playerPos.x - this.x;
            const dy = playerPos.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (playerPos.active) {
                // Strong attraction when very close to player (sucked up effect)
                const closeRange = 80; // Distance for strong attraction
                
                if (dist < closeRange) {
                    // Very strong attraction - direct pull toward player
                    const pullStrength = 8 + (closeRange - dist) / closeRange * 12; // 8-20 pull strength
                    this.vel.x += (dx / dist) * pullStrength * 0.3;
                    this.vel.y += (dy / dist) * pullStrength * 0.3;
                } else {
                    // Normal homing behavior when farther away
                    const homingSpeed = 2.0 + this.z * 0.4; // Faster homing: 2.6-3.2 speed
                    const turnRate = 0.08; // Faster turning (0-1)
                    
                    // Calculate desired velocity direction
                    const desiredVelX = (dx / dist) * homingSpeed;
                    const desiredVelY = (dy / dist) * homingSpeed;
                    
                    // Smoothly turn toward desired direction
                    this.vel.x = this.vel.x * (1 - turnRate) + desiredVelX * turnRate;
                    this.vel.y = this.vel.y * (1 - turnRate) + desiredVelY * turnRate;
                }
            }
        } else {
            // Normal star behavior - using dual-mode attraction like burst stars
            this.vel.x *= GAME_CONFIG.STAR_FRIC;
            this.vel.y *= GAME_CONFIG.STAR_FRIC;
            this.x += this.vel.x;
            this.y += this.vel.y;

            this.opacityOffset += this.twinkleSpeed;
            this.opacity = (Math.sin(this.opacityOffset) + 1) / 2 * 0.9 + 0.1;
            
            // Update rotation for spinning stars
            this.rotation += this.rotationSpeed;
            this.pulseOffset += this.pulseSpeed;
            
            // Dual-mode attraction similar to burst stars but for normal stars
            const dx = playerPos.x - this.x;
            const dy = playerPos.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            const attractDist = tractorEngaged ? GAME_CONFIG.ACTIVE_STAR_ATTRACT_DIST : GAME_CONFIG.PASSIVE_STAR_ATTRACT_DIST;
            
            if (playerPos.active && dist < attractDist) {
                const closeRange = 60; // Distance for strong attraction (smaller than burst stars)
                
                if (dist < closeRange) {
                    // Strong close-range attraction - direct pull toward player
                    const pullStrength = 4 + (closeRange - dist) / closeRange * 8; // 4-12 pull strength (weaker than burst stars)
                    this.vel.x += (dx / dist) * pullStrength * 0.2 * this.z; // Scale with depth
                    this.vel.y += (dy / dist) * pullStrength * 0.2 * this.z;
                } else {
                    // Normal attraction when farther away
                    const attractStrength = tractorEngaged ? GAME_CONFIG.ACTIVE_STAR_ATTR : GAME_CONFIG.PASSIVE_STAR_ATTR;
                    this.vel.x += (dx / dist) * attractStrength * this.z;
                    this.vel.y += (dy / dist) * attractStrength * this.z;
                }
            }
        }
        
        // Enhanced parallax effect with exponential scaling
        // Distant stars move much slower, close stars move faster
        // But burst stars don't have parallax - they're gameplay elements
        if (!this.isBurst) {
            const parallaxFactor = Math.pow(this.z, 2.5) * 0.25; // Increased exponent and multiplier for stronger parallax
            this.x -= shipVel.x * parallaxFactor;
            this.y -= shipVel.y * parallaxFactor;
            wrap(this, this.width, this.height);
        }
    }
    
    draw(ctx) {
        if (!this.active) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Apply rotation
        ctx.rotate(this.rotation);
        
        // Calculate dynamic radius with size variation and pulse
        const pulseMultiplier = 1 + Math.sin(this.pulseOffset) * 0.1; // Gentle pulsing
        const dynamicRadius = this.radius * this.sizeVariation * pulseMultiplier;
        
        // Adjust opacity based on depth - brighter overall
        const depthOpacity = Math.min(1, 0.5 + Math.pow(this.z / 4, 1.2));
        ctx.globalAlpha = this.opacity * depthOpacity;
        
        // Remove glow effects - use direct rendering for better visibility
        
        if (this.shape === 'point') {
            const borderSize = 1;
            ctx.fillStyle = this.borderColor;
            ctx.fillRect(
                -dynamicRadius / 2 - borderSize,
                -dynamicRadius / 2 - borderSize,
                dynamicRadius + borderSize * 2,
                dynamicRadius + borderSize * 2
            );
            ctx.fillStyle = this.color;
            ctx.fillRect(-dynamicRadius / 2, -dynamicRadius / 2, dynamicRadius, dynamicRadius);
        } else {
            ctx.beginPath();
            
            switch (this.shape) {
                case 'diamond':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(dynamicRadius * 0.7, 0);
                    ctx.lineTo(0, dynamicRadius);
                    ctx.lineTo(-dynamicRadius * 0.7, 0);
                    ctx.closePath();
                    break;
                    
                case 'triangle':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(dynamicRadius * 0.8, dynamicRadius * 0.5);
                    ctx.lineTo(-dynamicRadius * 0.8, dynamicRadius * 0.5);
                    ctx.closePath();
                    break;
                    
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const a = i * Math.PI / 3;
                        const x = Math.cos(a) * dynamicRadius;
                        const y = Math.sin(a) * dynamicRadius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                    
                case 'circle':
                    ctx.arc(0, 0, dynamicRadius, 0, Math.PI * 2);
                    break;
                    
                case 'square':
                    ctx.rect(-dynamicRadius * 0.7, -dynamicRadius * 0.7, dynamicRadius * 1.4, dynamicRadius * 1.4);
                    break;
                    
                case 'plus':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(0, dynamicRadius);
                    ctx.moveTo(-dynamicRadius, 0);
                    ctx.lineTo(dynamicRadius, 0);
                    break;
                    
                case 'x':
                    ctx.moveTo(-dynamicRadius, -dynamicRadius);
                    ctx.lineTo(dynamicRadius, dynamicRadius);
                    ctx.moveTo(dynamicRadius, -dynamicRadius);
                    ctx.lineTo(-dynamicRadius, dynamicRadius);
                    break;
                    
                case 'star4':
                    for (let i = 0; i < 8; i++) {
                        const a = i * Math.PI / 4;
                        const r = i % 2 === 0 ? dynamicRadius : dynamicRadius * 0.4;
                        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    break;
                    
                case 'star5':
                    for (let i = 0; i < 10; i++) {
                        const a = i * Math.PI / 5;
                        const r = i % 2 === 0 ? dynamicRadius : dynamicRadius * 0.4;
                        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    break;
                    
                case 'star6':
                    for (let i = 0; i < 12; i++) {
                        const a = i * Math.PI / 6;
                        const r = i % 2 === 0 ? dynamicRadius : dynamicRadius * 0.4;
                        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    break;
                    
                case 'star8':
                    for (let i = 0; i < 16; i++) {
                        const a = i * Math.PI / 8;
                        const r = i % 2 === 0 ? dynamicRadius : dynamicRadius * this.innerRadiusRatio;
                        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    break;
                    
                case 'sparkle':
                    // 8-pointed sparkle with varying lengths
                    for (let i = 0; i < 8; i++) {
                        const a = i * Math.PI / 4;
                        const length = (i % 2 === 0) ? dynamicRadius : dynamicRadius * 0.6;
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(a) * length, Math.sin(a) * length);
                    }
                    break;
                    
                case 'burst':
                    // Radiating lines of varying lengths
                    for (let i = 0; i < 12; i++) {
                        const a = i * Math.PI / 6;
                        const length = dynamicRadius * (0.5 + Math.random() * 0.5);
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(a) * length, Math.sin(a) * length);
                    }
                    break;
                    
                default:
                    // Default X shape
                    ctx.moveTo(-dynamicRadius, -dynamicRadius);
                    ctx.lineTo(dynamicRadius, dynamicRadius);
                    ctx.moveTo(dynamicRadius, -dynamicRadius);
                    ctx.lineTo(-dynamicRadius, dynamicRadius);
                    break;
            }
            
            ctx.strokeStyle = this.borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();
            
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 1.5 + this.z / 3; // Thicker lines for better visibility
            ctx.stroke();
        }
        
        // Add extra visibility for big stars without glow
        if (this.isBigStar) {
            ctx.save();
            ctx.globalAlpha = this.opacity * 0.8;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, dynamicRadius * 0.4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }
        
        ctx.restore();
    }
} 