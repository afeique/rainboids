// Color star entity - decorative stars with various shapes and behaviors
// Note: Burst stars (created from asteroid destruction) are still collectible
import { GAME_CONFIG, NORMAL_STAR_COLORS, STAR_SHAPES } from '../constants.js';
import { random, wrap } from '../utils.js';

function isMobile() {
    return window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse), (max-width: 768px)').matches;
}

export class ColorStar {
    constructor() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.active = false;
    }
    
    reset(x, y, burst = false, z, density) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.density = density;
        
        let scale = isMobile() ? GAME_CONFIG.MOBILE_SCALE : 1;
        
        // Radius and twinkle speed are now affected by density
        const densityFactor = 0.7 + (this.density || 0.5) * 0.6;
        
        // 5% chance for a "big star" - much larger and brighter
        const isBigStar = Math.random() < 0.05;
        if (isBigStar) {
            this.radius = (this.z * 1.8 + 0.8) * scale * densityFactor; // Big stars
            this.isBigStar = true;
        } else {
            this.radius = (this.z * 0.6 + 0.2) * scale * densityFactor; // Normal small stars
            this.isBigStar = false;
        }
        
        this.opacity = 0;
        this.opacityOffset = Math.random() * Math.PI * 2;
        this.twinkleSpeed = random(0.01, 0.03) * (1 + this.z * 0.3) * densityFactor;
        
        this.shape = STAR_SHAPES[Math.floor(Math.random() * STAR_SHAPES.length)];
        this.points = Math.floor(random(4, 7)) * 2;
        this.innerRadiusRatio = random(0.4, 0.8);
        
        // Add rotation and size variation
        this.rotation = 0;
        this.rotationSpeed = random(-0.02, 0.02);
        // Big stars get larger size variation
        if (this.isBigStar) {
            this.sizeVariation = random(1.2, 2.0); // Big stars: 120% to 200% size variation
        } else {
            this.sizeVariation = random(0.7, 1.3); // Normal stars: 70% to 130% size variation
        }
        this.pulseSpeed = random(0.005, 0.015);
        this.pulseOffset = Math.random() * Math.PI * 2;
        
        this.isBurst = burst;
        this.vel = { x: 0, y: 0 };
        this.active = true;
        
        if (burst) {
            // Burst stars are not generated by the noise field, so they need default values
            this.x = x || random(0, this.width);
            this.y = y || random(0, this.height);
            this.z = random(1.5, 3.0); // Close and bright
            this.density = 0.8;
            this.radius = (this.z * 1.2 + 0.4) * scale * 1.8; // Even larger for better visibility and collection

            // Initial velocity will be set by createStarBurst for explosion effect
            this.vel = { x: 0, y: 0 };
            this.color = '#00ff7f';
            this.borderColor = '#ffd700';
            this.life = 1800;
        } else {
            this.color = NORMAL_STAR_COLORS[Math.floor(Math.random() * NORMAL_STAR_COLORS.length)];
            this.borderColor = NORMAL_STAR_COLORS[Math.floor(Math.random() * NORMAL_STAR_COLORS.length)];
            this.life = -1;
        }
    }
    
    update(shipVel, playerPos, tractorEngaged) {
        if (!this.active) return;
        
        if (this.isBurst) {
            this.life--;
            if (this.life <= 0) {
                this.active = false;
                return;
            }
            
            this.vel.x *= GAME_CONFIG.STAR_FRIC;
            this.vel.y *= GAME_CONFIG.STAR_FRIC;
            this.x += this.vel.x;
            this.y += this.vel.y;
            
            this.opacity = Math.min(1, this.life / 120);
            
            // Home directly toward player
            const dx = playerPos.x - this.x;
            const dy = playerPos.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 1) {
                // Strengthened base homing behavior - always moves towards player
                const baseAttraction = 0.8; // Much stronger constant homing
                this.vel.x += (dx / dist) * baseAttraction * 0.15 * this.z;
                this.vel.y += (dy / dist) * baseAttraction * 0.15 * this.z;
                
                // Strong attraction at medium range (within 100 pixels)
                if (dist < 100) {
                    const strongAttraction = 15; // Stronger pull when in medium range
                    const proximityMultiplier = (100 - dist) / 100; // Stronger as it gets closer
                    this.vel.x += (dx / dist) * strongAttraction * proximityMultiplier * this.z;
                    this.vel.y += (dy / dist) * strongAttraction * proximityMultiplier * this.z;
                }
                
                // Very strong magnetic pull at close range (within 40 pixels)
                if (dist < 40) {
                    const magneticAttraction = 25; // Very strong pull when very close
                    const magneticMultiplier = (40 - dist) / 40; // Maximum strength when touching
                    this.vel.x += (dx / dist) * magneticAttraction * magneticMultiplier * this.z;
                    this.vel.y += (dy / dist) * magneticAttraction * magneticMultiplier * this.z;
                }
                
                // Enhanced attraction when tractor beam is active (works at longer range)
                if (tractorEngaged) {
                    let tractorAttraction = GAME_CONFIG.ACTIVE_STAR_ATTR * 1500; // Increased tractor strength
                    let tractorDist = GAME_CONFIG.ACTIVE_STAR_ATTRACT_DIST;
                    
                    if (dist < tractorDist) {
                        const tractorForce = tractorAttraction * (1 - dist / tractorDist);
                        this.vel.x += (dx / dist) * tractorForce * this.z;
                        this.vel.y += (dy / dist) * tractorForce * this.z;
                    }
                }
            }
        } else {
            // Update twinkle based on sine wave
            this.opacity = 0.3 + 0.7 * (Math.sin(Date.now() * this.twinkleSpeed + this.opacityOffset) + 1) / 2;
            
            // Rotate the star
            this.rotation += this.rotationSpeed;
            
            // Pulse size
            this.pulseOffset += this.pulseSpeed;
            
            // Non-burst stars are no longer attracted to player - they just exist for visual effect
            // Remove all tractor beam and attraction logic
        }
        
        // Enhanced parallax effect with exponential scaling
        // Distant stars move much slower, close stars move faster
        // But burst stars don't have parallax - they're gameplay elements
        if (!this.isBurst) {
            const parallaxFactor = Math.pow(this.z, 2.5) * 0.25; // Increased exponent and multiplier for stronger parallax
            this.x -= shipVel.x * parallaxFactor;
            this.y -= shipVel.y * parallaxFactor;
            wrap(this, this.width, this.height);
        }
    }
    
    draw(ctx) {
        if (!this.active) return;
        
        // Store rendering properties for batch rendering
        this.depthOpacity = Math.min(1, 0.5 + Math.pow(this.z / 4, 1.2));
        this.finalOpacity = this.opacity * this.depthOpacity;
        
        // For performance, use direct rendering for complex burst stars, sprite cache for others
        if (this.isBurst || this.shape === 'sparkle' || this.shape === 'burst') {
            // Direct rendering for special effects
            this.drawDirect(ctx);
        }
        // Simple stars will be batch rendered - this method just prepares properties
    }
    
    drawDirect(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Apply rotation
        ctx.rotate(this.rotation);
        
        // Calculate dynamic radius with size variation and pulse
        const pulseMultiplier = 1 + Math.sin(this.pulseOffset) * 0.1; // Gentle pulsing
        const dynamicRadius = this.radius * this.sizeVariation * pulseMultiplier;
        
        // Adjust opacity based on depth - brighter overall
        ctx.globalAlpha = this.finalOpacity;
        
        // Remove glow effects - use direct rendering for better visibility
        
        if (this.shape === 'point') {
            const borderSize = 1;
            ctx.fillStyle = this.borderColor;
            ctx.fillRect(
                -dynamicRadius / 2 - borderSize,
                -dynamicRadius / 2 - borderSize,
                dynamicRadius + borderSize * 2,
                dynamicRadius + borderSize * 2
            );
            ctx.fillStyle = this.color;
            ctx.fillRect(-dynamicRadius / 2, -dynamicRadius / 2, dynamicRadius, dynamicRadius);
        } else {
            ctx.beginPath();
            
            switch (this.shape) {
                case 'diamond':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(dynamicRadius * 0.7, 0);
                    ctx.lineTo(0, dynamicRadius);
                    ctx.lineTo(-dynamicRadius * 0.7, 0);
                    ctx.closePath();
                    break;
                    
                case 'triangle':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(dynamicRadius * 0.8, dynamicRadius * 0.5);
                    ctx.lineTo(-dynamicRadius * 0.8, dynamicRadius * 0.5);
                    ctx.closePath();
                    break;
                    
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const a = i * Math.PI / 3;
                        const x = Math.cos(a) * dynamicRadius;
                        const y = Math.sin(a) * dynamicRadius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                    
                case 'circle':
                    ctx.arc(0, 0, dynamicRadius, 0, Math.PI * 2);
                    break;
                    
                case 'square':
                    ctx.rect(-dynamicRadius * 0.7, -dynamicRadius * 0.7, dynamicRadius * 1.4, dynamicRadius * 1.4);
                    break;
                    
                case 'plus':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(0, dynamicRadius);
                    ctx.moveTo(-dynamicRadius, 0);
                    ctx.lineTo(dynamicRadius, 0);
                    break;
                    
                case 'x':
                    ctx.moveTo(-dynamicRadius, -dynamicRadius);
                    ctx.lineTo(dynamicRadius, dynamicRadius);
                    ctx.moveTo(dynamicRadius, -dynamicRadius);
                    ctx.lineTo(-dynamicRadius, dynamicRadius);
                    break;
                    
                case 'star4':
                    for (let i = 0; i < 8; i++) {
                        const a = i * Math.PI / 4;
                        const r = i % 2 === 0 ? dynamicRadius : dynamicRadius * 0.4;
                        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    break;
                    
                case 'star5':
                    for (let i = 0; i < 10; i++) {
                        const a = i * Math.PI / 5;
                        const r = i % 2 === 0 ? dynamicRadius : dynamicRadius * 0.4;
                        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    break;
                    
                case 'star6':
                    for (let i = 0; i < 12; i++) {
                        const a = i * Math.PI / 6;
                        const r = i % 2 === 0 ? dynamicRadius : dynamicRadius * 0.4;
                        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    break;
                    
                case 'star8':
                    for (let i = 0; i < 16; i++) {
                        const a = i * Math.PI / 8;
                        const r = i % 2 === 0 ? dynamicRadius : dynamicRadius * this.innerRadiusRatio;
                        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    break;
                    
                case 'sparkle':
                    // 8-pointed sparkle with varying lengths
                    for (let i = 0; i < 8; i++) {
                        const a = i * Math.PI / 4;
                        const length = (i % 2 === 0) ? dynamicRadius : dynamicRadius * 0.6;
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(a) * length, Math.sin(a) * length);
                    }
                    break;
                    
                case 'burst':
                    // Radiating lines of varying lengths
                    for (let i = 0; i < 12; i++) {
                        const a = i * Math.PI / 6;
                        const length = dynamicRadius * (0.5 + Math.random() * 0.5);
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(a) * length, Math.sin(a) * length);
                    }
                    break;
                    
                default:
                    // Default X shape
                    ctx.moveTo(-dynamicRadius, -dynamicRadius);
                    ctx.lineTo(dynamicRadius, dynamicRadius);
                    ctx.moveTo(dynamicRadius, -dynamicRadius);
                    ctx.lineTo(-dynamicRadius, dynamicRadius);
                    break;
            }
            
            ctx.strokeStyle = this.borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();
            
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 1.5 + this.z / 3; // Thicker lines for better visibility
            ctx.stroke();
        }
        
        // Add extra visibility for big stars without glow
        if (this.isBigStar) {
            ctx.save();
            ctx.globalAlpha = this.opacity * 0.8;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, dynamicRadius * 0.4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }
        
        // Special glow effect for burst stars to indicate they're collectible
        if (this.isBurst) {
            ctx.save();
            
            // Pulsing glow effect
            const pulseIntensity = 0.3 + 0.4 * Math.sin(Date.now() * 0.008 + this.x * 0.01);
            ctx.globalAlpha = this.finalOpacity * pulseIntensity;
            
            // Collection area indicator - subtle outer glow
            const collectionRadius = dynamicRadius + 15; // Match GAME_CONFIG.BURST_STAR_COLLECTION_BONUS
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 15;
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = this.finalOpacity * pulseIntensity * 0.3;
            
            ctx.beginPath();
            ctx.arc(0, 0, collectionRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Inner bright core for better visibility
            ctx.shadowBlur = 8;
            ctx.globalAlpha = this.finalOpacity * 0.9;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, dynamicRadius * 0.6, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.restore();
    }
    
    // Direct rendering fallback for simple shapes (used when batching is disabled or as fallback)
    drawDirectSimple(ctx) {
        if (!this.active) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Apply rotation
        ctx.rotate(this.rotation);
        
        // Calculate dynamic radius with size variation and pulse
        const pulseMultiplier = 1 + Math.sin(this.pulseOffset) * 0.1;
        const dynamicRadius = this.radius * this.sizeVariation * pulseMultiplier;
        
        // Use stored opacity
        ctx.globalAlpha = this.finalOpacity;
        
        if (this.shape === 'point') {
            const borderSize = 1;
            ctx.fillStyle = this.borderColor;
            ctx.fillRect(
                -dynamicRadius / 2 - borderSize,
                -dynamicRadius / 2 - borderSize,
                dynamicRadius + borderSize * 2,
                dynamicRadius + borderSize * 2
            );
            ctx.fillStyle = this.color;
            ctx.fillRect(-dynamicRadius / 2, -dynamicRadius / 2, dynamicRadius, dynamicRadius);
        } else if (this.shape === 'circle') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, dynamicRadius, 0, 2 * Math.PI);
            ctx.fill();
        } else {
            // Simple stroke rendering for other shapes
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 1.5 + this.z / 3;
            ctx.beginPath();
            
            switch (this.shape) {
                case 'diamond':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(dynamicRadius * 0.7, 0);
                    ctx.lineTo(0, dynamicRadius);
                    ctx.lineTo(-dynamicRadius * 0.7, 0);
                    ctx.closePath();
                    break;
                case 'triangle':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(dynamicRadius * 0.8, dynamicRadius * 0.5);
                    ctx.lineTo(-dynamicRadius * 0.8, dynamicRadius * 0.5);
                    ctx.closePath();
                    break;
                case 'plus':
                    ctx.moveTo(0, -dynamicRadius);
                    ctx.lineTo(0, dynamicRadius);
                    ctx.moveTo(-dynamicRadius, 0);
                    ctx.lineTo(dynamicRadius, 0);
                    break;
                case 'x':
                    ctx.moveTo(-dynamicRadius, -dynamicRadius);
                    ctx.lineTo(dynamicRadius, dynamicRadius);
                    ctx.moveTo(dynamicRadius, -dynamicRadius);
                    ctx.lineTo(-dynamicRadius, dynamicRadius);
                    break;
                default:
                    // Default to circle
                    ctx.arc(0, 0, dynamicRadius, 0, 2 * Math.PI);
                    break;
            }
            
            ctx.stroke();
        }
        
        ctx.restore();
    }
} 